#lang sicp

;; NEED TO DO MY OWN ANALYSIS ON THIS ... 
;; https://billthelizard.blogspot.com/2009/12/sicp-exercise-114-counting-change.html

;; Exercise 1.14

; Space - As we saw in the Fibonacci procedure in section 1.2.2, the space required by the count-change procedure grows linearly with the input.
; The space required is proportional to the maximum depth of the tree. At any point in the computation we only need to keep track of the nodes above the current node.
;
; Since the height of the tree is proportional to the amount to be changed, the order of growth of the space required by the count-change procedure is O(n).
; Number of steps - The diagram illustrates that this procedure, much like the recursive procedure for computing Fibonacci numbers that we saw before, in not very efficient. Much of the computation being done is repeated.
; If we look closely at a call to cc where kinds-of-coins is equal to one, we can see each call generates two more calls until we reach a terminal node.
; If we define the function T(a, k) to be the number of calls to cc generated by calling (cc n k), where n is the amount and k is the number of kinds of coins, then
;
; T(n, 1) = 2n + 1
;
; or in Big-O notation,
;
; T(n, 1) = O(n)
;
; Now let's take a look at a partial graph of a call to (cc 50 2).
;
; There are two interesting things to point out here. First, there are n/5 calls to cc made where k = 2 kinds of coins
; (look down the right hand side of the diagram above). This is because each call is made with 5 cents less in the amount
; argument until a terminal node is reached. The second interesting thing is that each of these n/5 calls to (cc n 2)
; generates an entire (cc n 1) subtree.
;
;
; That means that
;
; T(n, 2) = (n/5) * 2n + 1
;
; and because of the multiplication of terms
;
; T(n, 2) = O(n2)
;
; Similarly, if we look at the graph of (cc 50 3) we can see n/10 calls to cc where k = 3, each of which generates its own (cc n 2) subtree.
;
; From this we find that
;
; T(n, 3) = O(n3)
;
; Finally, it's easy enough to show that we'll get the same pattern when k = 4 and k = 5. The n/50 nodes generated when k = 5 each generate n/25 nodes
; with k = 4, each of which generates a node where k = 3. And so the final answer we arrive at for the time complexity of the count-change procedure with
; five kinds of coins is
;
; T(n, 5) = O(n5)

